/*
    Precached - A Linux process monitor and pre-caching daemon
    Copyright (C) 2017 the precached developers

    This file is part of precached.

    Precached is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Precached is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Precached.  If not, see <http://www.gnu.org/licenses/>.
*/

extern crate chrono;
extern crate clap;
#[macro_use]
extern crate lazy_static;
#[macro_use]
extern crate log;
extern crate nix;
extern crate pretty_env_logger;
#[macro_use]
extern crate serde_derive;
extern crate toml;
extern crate zstd;

use chrono::{DateTime, Utc};
use clap::{App, AppSettings, Arg, SubCommand};
use std::path::Path;

mod util;
mod process;
mod iotrace;
mod constants;


/// Runtime configuration for iotracectl
#[derive(Debug, Clone)]
pub struct Config<'a> {
    /// The verbosity of text output
    pub verbosity: u8,
    pub matches: clap::ArgMatches<'a>,
}

impl<'a> Config<'a> {
    pub fn new() -> Config<'a> {
        trace!("Parsing command line...");

        let matches = App::new("iotracectl")
            .version("0.1.0")
            .author("X3n0m0rph59 <x3n0m0rph59@gmail.com>")
            .about("Manage I/O traces generated by precached")
            .setting(AppSettings::GlobalVersion)
            .setting(AppSettings::DeriveDisplayOrder)
            .arg(
                Arg::with_name("v")
                    .short("v")
                    .multiple(true)
                    .help("Sets the level of output verbosity"),
            )
            .arg(
                Arg::with_name("config")
                    .short("c")
                    .long("config")
                    .value_name("file")
                    .help("The precached config file to use")
                    .default_value(constants::CONFIG_FILE)
                    .takes_value(true),
            )
            .subcommand(
                SubCommand::with_name("status")
                    .setting(AppSettings::DeriveDisplayOrder)
                    .about("Show the current status of the precached I/O tracing subsystem")
                    .arg(
                        Arg::with_name("long")
                            .short("l")
                            .help("Use long display format"),
                    ),
            )
            .subcommand(
                SubCommand::with_name("top")
                    .setting(AppSettings::DeriveDisplayOrder)
                    .about("Top/htop like display of in-flight I/O traces"),
            )
            .subcommand(
                SubCommand::with_name("list")
                    .setting(AppSettings::DeriveDisplayOrder)
                    .about("List all available I/O traces")
                    .arg(
                        Arg::with_name("full")
                            .long("full")
                            .short("f")
                            .conflicts_with("short")
                            .help("Use full display format"),
                    )
                    .arg(
                        Arg::with_name("short")
                            .long("short")
                            .short("s")
                            .conflicts_with("full")
                            .help("Use short display format"),
                    ),
            )
            .subcommand(
                SubCommand::with_name("info")
                    .setting(AppSettings::DeriveDisplayOrder)
                    .alias("show")
                    .about("Display metadata of I/O traces")
                    .help("Print metadata information about specific I/O traces"),
            )
            .subcommand(
                SubCommand::with_name("dump")
                    .setting(AppSettings::DeriveDisplayOrder)
                    .about("Dump I/O trace")
                    .arg(
                        Arg::with_name("long")
                            .short("l")
                            .help("Use long display format"),
                    )
                    .help("Dump I/O traces to the console"),
            )
            .subcommand(
                SubCommand::with_name("remove")
                    .setting(AppSettings::DeriveDisplayOrder)
                    .alias("delete")
                    .about("Remove I/O trace")
                    .arg(
                        Arg::with_name("long")
                            .short("l")
                            .help("Use long display format"),
                    )
                    .help("Remove I/O traces"),
            )
            .subcommand(
                SubCommand::with_name("help")
                    .setting(AppSettings::DeriveDisplayOrder)
                    .about("Display this short help text"),
            )
            .subcommand(
                SubCommand::with_name("test-tracing")
                    .setting(AppSettings::DeriveDisplayOrder)
                    .about("Test the I/O tracing subsystem of precached")
                    .arg(
                        Arg::with_name("long")
                            .short("l")
                            .help("Use long display format"),
                    )
                    .help("Test the I/O tracing subsystem of precached"),
            )
            .get_matches();

        Config {
            verbosity: matches.occurrences_of("v") as u8,
            matches: matches,
        }
    }
}

/// Print a license header to the console
fn print_license_header() {
    println!(
        "precached Copyright (C) 2017 the precached team
This program comes with ABSOLUTELY NO WARRANTY;
This is free software, and you are welcome to redistribute it
under certain conditions.
"
    );
}

/// Returns true if all of the supplied filters match the I/O trace
fn filter_matches() -> bool {
    true
}

fn print_io_trace(io_trace: &iotrace::IOTraceLog, config: &Config) {
    let matches = config.matches.subcommand_matches("list").unwrap();
    let flags = vec!["Valid", "Current"];

    if matches.is_present("full") {
        // Print in "full" format
        println!(
            "Executable:\t{}\nCommand:\t{}\nHash:\t\t{}\nCreation Date:\t{}\nTrace End Date:\t{}\n\
             Compression:\tZstd\nNum Files:\t{}\nNum I/O Ops:\t{}\nFlags:\t\t{:?}\n\n",
            io_trace.exe,
            io_trace.comm,
            io_trace.hash,
            io_trace
                .created_at
                .format(constants::DATETIME_FORMAT_DEFAULT)
                .to_string(),
            io_trace
                .trace_stopped_at
                .format(constants::DATETIME_FORMAT_DEFAULT)
                .to_string(),
            io_trace.file_map.len(),
            io_trace.trace_log.len(),
            flags
        );
    } else {
        // Print in "short" format
        println!(
            "Executable:\t{}\nCreation Date:\t{}\nTrace End Date:\t{}\nNum I/O Ops:\t{}\n\
             Flags:\t\t{:?}\n\n",
            io_trace.exe,
            io_trace
                .created_at
                .format(constants::DATETIME_FORMAT_DEFAULT)
                .to_string(),
            io_trace
                .trace_stopped_at
                .format(constants::DATETIME_FORMAT_DEFAULT)
                .to_string(),
            io_trace.trace_log.len(),
            flags
        );
    }
}

/// Top/Htop like display of the I/O tracing subsystem
fn io_trace_top() {
    info!("Not implemented!");
}

/// Print the status of the I/O tracing subsystem
fn print_io_trace_status() {
    println!("Status of matching I/O tracing:");
}

/// Enumerate all I/O traces and display them in the specified format
fn list_io_traces(config: &Config, daemon_config: util::ConfigFile) {
    println!("Listing matching I/O traces:\n");

    let state_dir = daemon_config
        .state_dir
        .unwrap_or(String::from(constants::STATE_DIR));
    let traces_path = String::from(
        Path::new(&state_dir)
            .join(Path::new(&constants::IOTRACE_DIR))
            .to_string_lossy(),
    );

    let mut counter = 0;
    let mut errors = 0;

    match util::walk_directories(&vec![traces_path], &mut |path| {
        trace!("{:?}", path);

        // TODO:
        // test if the trace is valid at all
        // test if the trace is older than the binary (out-of-date)
        // test that the binary does exist (bin-does-not-exist)
        // test if the trace is from last run of binary!? (current or not-current)

        let filename = String::from(path.to_string_lossy());
        match iotrace::IOTraceLog::from_file(&filename) {
            Err(e) => {
                error!("Corrupted I/O trace, or file not readable: {}", e);
                errors += 1;
            }
            Ok(io_trace) => {
                print_io_trace(&io_trace, config);
            }
        }

        counter += 1;
    }) {
        Err(e) => error!("Error during enumeration of I/O trace files: {}", e),
        _ => { /* Do nothing */ }
    }

    if counter < 1 {
        println!("There are currently no I/O traces available");
    } else {
        println!(
            "Summary: {} I/O trace files processed, {} errors occured",
            counter,
            errors
        );
    }
}

/// Display metadata of an I/O trace in the specified format
fn print_info_about_io_traces() {
    println!("I/O trace metadata:");
}

/// Dump the raw I/O trace data
fn dump_io_traces() {
    println!("I/O trace dump:");
}

/// Remove I/O traces
fn remove_io_traces() {
    trace!("Remove I/O traces...");
}

/// Verify that I/O tracing works as expected
/// Test all parts of the system
fn perform_tracing_test() {
    trace!("Performing I/O tracing test...");

    // TODO:
    // create test files /tmp/{1..3}.test

    // fork()

    // open test files

    // read files

    // open test files in reverse order

    // read files

    // Exit

    // waitpid()

    // find iotrace of test process

    // Verify

    trace!("Test finished");
}

/// Print help message on how to use this command
fn print_help() {
    println!("NOTE: Usage information: iotracectl --help");
}

/// Print usage message on how to use this command
fn print_usage() {
    println!("NOTE: Usage information: iotracectl --help");
}

/// Program entrypoint
fn main() {
    if unsafe { nix::libc::isatty(0) } == 1 {
        print_license_header();
    }

    pretty_env_logger::init().expect("Could not initialize the logging subsystem!");

    trace!("Startup");

    // parses the command line
    let config = Config::new();

    // load external text configuration
    let filename = String::from(config.matches.value_of(String::from("config")).unwrap());
    trace!("Loading external configuration from '{}'", filename);
    let daemon_config = util::ConfigFile::from_file(&filename).unwrap_or_default();

    // Decide what to do
    if let Some(command) = config.matches.subcommand_name() {
        match command {
            "status" => {
                print_io_trace_status();
            }
            "top" => {
                io_trace_top();
            }
            "list" => {
                list_io_traces(&config, daemon_config.clone());
            }
            "info" | "show" => {
                print_info_about_io_traces();
            }
            "dump" => {
                dump_io_traces();
            }
            "remove" | "delete" => {
                remove_io_traces();
            }
            "help" => {
                print_help();
            }
            "test-tracing" => {
                perform_tracing_test();
            }
            &_ => {
                print_usage();
            }
        }
    } else {
        print_usage();
    }

    trace!("Exit");
}
