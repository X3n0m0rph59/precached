# Precached - A Linux process monitor and pre-caching daemon

This document will give you a brief high level introduction of the
precached project.

Note: This document is a work-in-progress and shall be considered
*draft status*.

## Project Overview

Precached is a Linux daemon that is written in the Rust programming
language. It tries to improve system performance by loading data that will
most likely be referenced soon from slow mass storage like spinning
hard disks, into the system's RAM.

Generally speaking: precached tries to keep the most often used
programs in the caches (page cache, dentry cache). Additionally precached is
able to perform readahead on files that are *not currently cached*, when a
process is executed (online prefetching, during application startup).

The precached daemon records which files are accessed on application startup
by using the Linux ftrace subsystem and later uses these generated I/O trace
logs to dynamically load the previously accessed files into the kernel's page
cache. Thus when using precached the most often used applications are
*cache hot* most of the time and will load much faster compared to their
*cache cold* startup times.

Thus the theoretical maximum improvement that can be delivered by precached
is to make *every* application launch *cache hot*, ideally immediately after
the user logged in.

### Current State of the Project

Precached is in an early stage of development! You may still encounter some
serious bugs.

The basic functionality should be working though.

### Software Architecture

As said before, precached is written in the excellent programming language
called "Rust". We believe that the choice of programming language
contributes to the overall stability and security of a software system.

#### 10.000 Foot View on the Project

The precached daemon is comprised of a small core which only implements
the most basic functionality:

  * A leightweight Linux daemon
  * `Hooks` and `Plugins` mechanisms
  * Messaging subsystem to deliver and handle internal events
  * A Linux inotify shim layer
  * A D-BUS interface
  * A POSIX Signals interface

The daemon proper is then extended by "plugins" and "hooks", which deliver
the actual features, like e.g.: "generation of I/O trace logs" or "prefetching
of data into RAM" and much more...

The difference between Hooks and Plugins explained:

  * Hooks may not be disabled, Plugins can be disabled dynamically
  * Hooks have direct access to the low level `procmon` events, plugins have not
  * Hooks are designed to be considered first by the internal message delivery system
  * The hooks interface is designed for small components that trap system events and
    generate daemon internal messages, that subsequently get processed by one or multiple plugins
  * The plugin interface is designed for implementing additional functionality, possibly
    utilizing events previously generated by hooks

The precached daemon makes use of a multi-threaded software architecture design
and tries to utilize the available cpu cores as efficiently as possible.

It spins up multiple threads:

  * precached main thread - Coordinates all other threads
  * event loop - Listens for procmon events and delivers them to the main thread
  * ftrace - This thread processes the event stream of the Linux ftrace subsystem
  * worker (4) - Thread pool that executes background tasks of lower priority (e.g.: task scheduler)
  * prefetch (NCPUs) - Thread pool that is used to asynchronously read data from slow mass storage devices into ram

#### Design Considerations

We chose a plugin based software architecture for precached to be able to
easily extend its functionality in the future.

#### Available Plugins and Hooks

The following plugins are available for precached (as of 2017-11-21)

  * Inotify Multiplexer (experimental) - Translate low level inotify events to daemon internal messages
  * I/O Trace Log Manager (stable) - Manage I/O trace logs, optimizes new trace logs, and removes invalid ones
  * I/O Trace Log Cache (experimental) - mlock() .iotrace files into memory
  * Markov Log Manager (not implemented/in development)
  * Hot Applications (stable) - Offline prefetching of the most often used applications, "locks the desktop into memory"
  * Metrics (stable) - Generate system metrics and deliver events based on them
  * Statistics (stable) - Generate statistics using data from Metrics plugin
  * Notifications (stable) - Desktop notifications using D-BUS
  * Custom Rules (not implemented/in development)
  * System Agent (not implemented/in development)
  * User Session (experimental) - Cache metadata of files in logged user's home directories
  * I/O Trace Log Cache (experimental) - mlock() .iotrace files into memory
  * VFS Stat(x) Cache (stable) - Prime the kernel’s dentry caches by walking directories and stat()ing files
  * Static Blacklist (stable) - Blacklist files that shall not be accessed by the precached daemon
  * Static Whitelist (stable) - Force caching of files or applications into memory
  * ftrace Messages (stable) - Insert custom messages into the Linux ftrace subsystems event stream
  * Fork Bomb Mitigation (not implemented/in development)

The following hooks are available for precached (as of 2017-11-21)

  * ftrace logger (stable) - Generate I/O trace logs by utilising the Linux ftrace subsystem
  * ptrace logger (deprecated) - Generate I/O trace logs by `ptrace()` ing processes and trapping system calls
  * Fork Bomb detector (not implemented/in development)
  * I/O Trace Prefetcher (in development) - Prefetch files using a previously recorded I/O trace log
  * Markov Prefetcher (not implemented/in development)
  * Process Tracker (stable) - Track `fork()` and `exec()` events of processes running on the system
  * Rule Hook (not implemented/in development)

#### Implementation of Process Tracking

The Linux kernel offers an interface called `Proc Connector` that notifies
interested parties of "process related" events like `fork()` or `exec()` via
messages sent over a netlink socket from the kernel to userspace.
By using the aforementioned API we can avoid to poll the procfs, and stay
strictly event based. This makes possible the implementation of online
prefetching, and allows for a much better software design than the polling
variant would have been. The `Proc Connector` is implemented in the crate
`procmon-sys` and used by the crate `procmon`.

### Benchmark Results

The preliminary benchmarks that we took are looking very promising already.
We used the current development version of precached (as of 2017-10-30) and
ran some benchmarks on it:

The benchmarks confirmed that precached is able to speed up load times of
mid-sized and huge applications on Linux. We nearly achieve cache hot load
times on first run (after system bootup) of applications like e.g. LibreOffice
and Firefox. After a memory hog process exited we need a short amount of idle
time (roughly ~30 secs) to re-prime the caches, after that we achieve
cache hot load times again. We did not discover any corner cases at which
the system performed significantly worse than without precached running.
The system feels much more ‘snappier’ even directly after login.
Bootup is slowed down somewhat though, since we read approximately 2GB of
additional data into the RAM cache (in our test setup).
This happens with a raised nice level and mostly during the GDM greeter’s
password prompt and thereafter. We are investigating the possibility to
move the offline prefetch phase somewhat further into the startup process
to achieve even faster boot times (delayed prefetching).

#### Specifications of *System No. 1*:
```
  ~7 year old laptop running Fedora Core 27
  Dual Core Intel CPU
  4GB DDR3 RAM
  500GB HDD, BFQ I/O Scheduler
  Linux 4.14
```

|Application      |Stock|precached|Cache Hot|
|-----------------|----:|--------:|--------:|
|System Bootup    |1:30 |1:39     |n.a.     |
|LibreOffice Calc |19   |4        |4        |
|Firefox 57       |15   |4        |3.5      |

_Application load times (in seconds, M:SS) on first run after bootup_


#### Specifications of *System No. 2*:
```
  ~5 year old laptop running Fedora Core 27
  Quad Core Intel CPU
  4GB DDR3 RAM
  256GB SATA-3 fast SSD, CFQ I/O Scheduler
  Linux 4.14
```

|Application      |Stock|precached|Cache Hot|
|-----------------|----:|--------:|--------:|
|System Bootup    |28.5 |32       |n.a.     |
|LibreOffice Calc |6.5  |3        |3        |
|Firefox 57       |7    |3.5      |3        |

_Application load times (in seconds) on first run after bootup_

For further information please see the 
[precached project website](https://x3n0m0rph59.github.io/precached/).

### Related Software Projects

There are other projects tackling this problem domain

* [preload by Behdad Esfahbod](http://behdad.org/download/preload.pdf)
* [memlockd by Russel Coker](https://doc.coker.com.au/projects/memlockd/)
* [vmtouch by Hoytech](https://hoytech.com/vmtouch/)

### Further reading

* LWN.net has some great articles on Linux memory management
